package com.personalcoacher.data.local.entity

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import com.personalcoacher.domain.model.DailyApp
import com.personalcoacher.domain.model.DailyAppStatus
import com.personalcoacher.domain.model.SyncStatus
import java.time.Instant

/**
 * Room entity for AI-generated daily web apps.
 * Each app is a complete, self-contained HTML/CSS/JS mini-application
 * generated by Claude based on the user's journal entries.
 */
@Entity(
    tableName = "daily_apps",
    indices = [
        Index(value = ["userId", "date"]),
        Index(value = ["userId", "status"]),
        Index(value = ["syncStatus"])
    ]
)
data class DailyAppEntity(
    @PrimaryKey
    val id: String,
    val userId: String,
    val date: Long,                    // Date the app was generated for (epoch millis)

    // App content
    val title: String,
    val description: String,           // Why this app was suggested based on journal context
    val htmlCode: String,              // Complete HTML/CSS/JS code
    val journalContext: String?,       // Summary of relevant journal entries that inspired this

    // User interaction
    val status: String,                // "pending", "liked", "disliked" (DailyAppStatus)
    val usedAt: Long?,                 // When user first opened the app

    // Timestamps and sync
    val createdAt: Long,
    val updatedAt: Long,
    val syncStatus: String             // SyncStatus: LOCAL_ONLY, SYNCING, SYNCED
) {
    fun toDomainModel(): DailyApp {
        return DailyApp(
            id = id,
            userId = userId,
            date = Instant.ofEpochMilli(date),
            title = title,
            description = description,
            htmlCode = htmlCode,
            journalContext = journalContext,
            status = DailyAppStatus.valueOf(status),
            usedAt = usedAt?.let { Instant.ofEpochMilli(it) },
            createdAt = Instant.ofEpochMilli(createdAt),
            updatedAt = Instant.ofEpochMilli(updatedAt),
            syncStatus = SyncStatus.valueOf(syncStatus)
        )
    }

    companion object {
        fun fromDomainModel(app: DailyApp): DailyAppEntity {
            return DailyAppEntity(
                id = app.id,
                userId = app.userId,
                date = app.date.toEpochMilli(),
                title = app.title,
                description = app.description,
                htmlCode = app.htmlCode,
                journalContext = app.journalContext,
                status = app.status.name,
                usedAt = app.usedAt?.toEpochMilli(),
                createdAt = app.createdAt.toEpochMilli(),
                updatedAt = app.updatedAt.toEpochMilli(),
                syncStatus = app.syncStatus.name
            )
        }
    }
}
